<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>ReflectionTypes.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Java Types</a> &gt; <a href="index.source.html" class="el_package">net.florianschoppmann.java.reflect</a> &gt; <span class="el_source">ReflectionTypes.java</span></div><h1>ReflectionTypes.java</h1><pre class="source lang-java linenums">package net.florianschoppmann.java.reflect;

import net.florianschoppmann.java.type.AbstractTypes;
import net.florianschoppmann.java.type.IntersectionType;

import javax.annotation.Nullable;
import javax.lang.model.element.Element;
import javax.lang.model.element.Name;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.TypeParameterElement;
import javax.lang.model.type.ArrayType;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.ExecutableType;
import javax.lang.model.type.NoType;
import javax.lang.model.type.NullType;
import javax.lang.model.type.PrimitiveType;
import javax.lang.model.type.TypeKind;
import javax.lang.model.type.TypeMirror;
import java.lang.reflect.GenericArrayType;
import java.lang.reflect.GenericDeclaration;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.TypeVariable;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/**
 * Implementation of {@link javax.lang.model.util.Types} backed by the Java Reflection API.
 *
 * &lt;p&gt;All {@link Element} and {@link TypeMirror} objects returned by this class are immutable and therefore thread-safe.
 * Likewise, only a stateless (and thus thread-safe) singleton instance of this class is available via
 * {@link #getInstance()}.
 *
 * &lt;p&gt;Currently unsupported are (resulting in an {@link UnsupportedOperationException}):
 * &lt;ul&gt;&lt;li&gt;
 *     Type parameters in method declarations. See {@link #typeMirror(Type)} for details.
 * &lt;/li&gt;&lt;li&gt;
 *     {@link #directSupertypes(TypeMirror)}
 * &lt;/li&gt;&lt;li&gt;
 *     {@link #asMemberOf(DeclaredType, Element)}
 * &lt;/li&gt;&lt;li&gt;
 *     {@link #isAssignable(TypeMirror, TypeMirror)}
 * &lt;/li&gt;&lt;li&gt;
 *     {@link #isSubsignature(ExecutableType, ExecutableType)}
 * &lt;/li&gt;&lt;/ul&gt;
 */
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">public final class ReflectionTypes extends AbstractTypes {</span>
<span class="fc" id="L54">    private static final ReflectionTypes INSTANCE = new ReflectionTypes();</span>

    private final ImmutableList&lt;PrimitiveTypeImpl&gt; primitiveTypes;
    private final ImmutableList&lt;TypeElementImpl&gt; boxedTypeDeclarations;
    {
<span class="fc" id="L59">        List&lt;PrimitiveTypeImpl&gt; newTypes = new ArrayList&lt;&gt;(TypeKind.values().length);</span>
<span class="fc" id="L60">        List&lt;TypeElementImpl&gt; newDeclarations = new ArrayList&lt;&gt;(TypeKind.values().length);</span>

<span class="fc" id="L62">        newTypes.addAll(Collections.&lt;PrimitiveTypeImpl&gt;nCopies(TypeKind.values().length, null));</span>
<span class="fc" id="L63">        newDeclarations.addAll(Collections.&lt;TypeElementImpl&gt;nCopies(TypeKind.values().length, null));</span>

<span class="fc" id="L65">        addPrimitive(newTypes, newDeclarations, TypeKind.DOUBLE, PrimitiveTypeImpl.DOUBLE, Double.class);</span>
<span class="fc" id="L66">        addPrimitive(newTypes, newDeclarations, TypeKind.FLOAT, PrimitiveTypeImpl.FLOAT, Float.class);</span>
<span class="fc" id="L67">        addPrimitive(newTypes, newDeclarations, TypeKind.LONG, PrimitiveTypeImpl.LONG, Long.class);</span>
<span class="fc" id="L68">        addPrimitive(newTypes, newDeclarations, TypeKind.INT, PrimitiveTypeImpl.INT, Integer.class);</span>
<span class="fc" id="L69">        addPrimitive(newTypes, newDeclarations, TypeKind.SHORT, PrimitiveTypeImpl.SHORT, Short.class);</span>
<span class="fc" id="L70">        addPrimitive(newTypes, newDeclarations, TypeKind.BYTE, PrimitiveTypeImpl.BYTE, Byte.class);</span>
<span class="fc" id="L71">        addPrimitive(newTypes, newDeclarations, TypeKind.CHAR, PrimitiveTypeImpl.CHAR, Character.class);</span>
<span class="fc" id="L72">        addPrimitive(newTypes, newDeclarations, TypeKind.BOOLEAN, PrimitiveTypeImpl.BOOLEAN, Boolean.class);</span>

<span class="fc" id="L74">        primitiveTypes = ImmutableList.copyOf(newTypes);</span>
<span class="fc" id="L75">        boxedTypeDeclarations = ImmutableList.copyOf(newDeclarations);</span>
    }

<span class="fc" id="L78">    private ReflectionTypes() { }</span>

    /**
     * Returns the singleton instance of this class.
     *
     * &lt;p&gt;Since this class does not contain any state, and since it is immutable, the returned instance is thread-safe.
     *
     * @return the singleton instance of this class
     */
    public static ReflectionTypes getInstance() {
<span class="fc" id="L88">        return INSTANCE;</span>
    }

    @Override
    protected void requireValidElement(Element element) {
<span class="fc" id="L93">        Objects.requireNonNull(element);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        if (!(element instanceof ReflectionElement)) {</span>
<span class="fc" id="L95">            throw new IllegalArgumentException(String.format(</span>
                &quot;Expected %s instance that was created by %s, but got instance of %s.&quot;,
<span class="fc" id="L97">                Element.class.getSimpleName(), ReflectionTypes.class, element.getClass()</span>
            ));
        }
<span class="fc" id="L100">    }</span>

    @Override
    protected void requireValidType(@Nullable TypeMirror type) {
<span class="fc bfc" id="L104" title="All 4 branches covered.">        if (!(type instanceof ReflectionTypeMirror) &amp;&amp; type != null) {</span>
<span class="fc" id="L105">            throw new IllegalArgumentException(String.format(</span>
                &quot;Expected %s instance that was created by %s, but got instance of %s.&quot;,
<span class="fc" id="L107">                TypeMirror.class.getSimpleName(), ReflectionTypes.class, type.getClass()</span>
            ));
        }
<span class="fc" id="L110">    }</span>

    private void addPrimitive(List&lt;PrimitiveTypeImpl&gt; newPrimitiveTypes, List&lt;TypeElementImpl&gt; newBoxedTypeDeclarations,
            TypeKind kind, PrimitiveTypeImpl primitiveType, Class&lt;?&gt; clazz) {
<span class="fc" id="L114">        newPrimitiveTypes.set(kind.ordinal(), primitiveType);</span>
<span class="fc" id="L115">        newBoxedTypeDeclarations.set(kind.ordinal(), ((DeclaredTypeImpl) typeMirror(clazz)).asElement());</span>
<span class="fc" id="L116">    }</span>

    @Override
    public TypeElement boxedClass(PrimitiveType primitiveType) {
<span class="fc" id="L120">        requireValidType(Objects.requireNonNull(primitiveType));</span>
<span class="fc" id="L121">        @Nullable TypeElementImpl typeElement = boxedTypeDeclarations.get(primitiveType.getKind().ordinal());</span>
<span class="pc bpc" id="L122" title="2 of 4 branches missed.">        assert typeElement != null : &quot;Array with boxed type declarations incorrectly initialized.&quot;;</span>
<span class="fc" id="L123">        return typeElement;</span>
    }

    @Override
    public PrimitiveType unboxedType(TypeMirror type) {
<span class="fc" id="L128">        requireValidType(Objects.requireNonNull(type));</span>

<span class="fc bfc" id="L130" title="All 2 branches covered.">        if (type.getKind() != TypeKind.DECLARED) {</span>
<span class="fc" id="L131">            throw new IllegalArgumentException(String.format(</span>
                &quot;Expected type mirror of kind %s, but got %s.&quot;, TypeKind.DECLARED, type
            ));
        }

<span class="fc" id="L136">        Name name = ((DeclaredTypeImpl) type).asElement().getQualifiedName();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        if (name.contentEquals(Double.class.getName())) {</span>
<span class="fc" id="L138">            return PrimitiveTypeImpl.DOUBLE;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        } else if (name.contentEquals(Float.class.getName())) {</span>
<span class="fc" id="L140">            return PrimitiveTypeImpl.FLOAT;</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">        } else if (name.contentEquals(Long.class.getName())) {</span>
<span class="fc" id="L142">            return PrimitiveTypeImpl.LONG;</span>
<span class="fc bfc" id="L143" title="All 2 branches covered.">        } else if (name.contentEquals(Integer.class.getName())) {</span>
<span class="fc" id="L144">            return PrimitiveTypeImpl.INT;</span>
<span class="fc bfc" id="L145" title="All 2 branches covered.">        } else if (name.contentEquals(Short.class.getName())) {</span>
<span class="fc" id="L146">            return PrimitiveTypeImpl.SHORT;</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        } else if (name.contentEquals(Byte.class.getName())) {</span>
<span class="fc" id="L148">            return PrimitiveTypeImpl.BYTE;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">        } else if (name.contentEquals(Character.class.getName())) {</span>
<span class="fc" id="L150">            return PrimitiveTypeImpl.CHAR;</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        } else if (name.contentEquals(Boolean.class.getName())) {</span>
<span class="fc" id="L152">            return PrimitiveTypeImpl.BOOLEAN;</span>
        } else {
<span class="fc" id="L154">            throw new IllegalArgumentException(String.format(&quot;Expected boxed type, but got %s.&quot;, type));</span>
        }
    }

    /**
     * Returns a type mirror for the given {@link Class} object.
     */
    private ReflectionTypeMirror mirrorClass(Class&lt;?&gt; clazz, MirrorContext mirrorContext) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (clazz.isArray()) {</span>
<span class="fc" id="L163">            return new ArrayTypeImpl(mirrorContext.mirror(clazz.getComponentType()));</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">        } else if (clazz.isPrimitive()) {</span>
<span class="fc" id="L165">            return (ReflectionTypeMirror) getPrimitiveType(TypeKind.valueOf(clazz.getName().toUpperCase()));</span>
        } else {
            // raw type
<span class="fc" id="L168">            @Nullable Class&lt;?&gt; enclosingClass = clazz.getEnclosingClass();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            ReflectionTypeMirror enclosingType = enclosingClass == null</span>
                ? NoTypeImpl.NONE
<span class="fc" id="L171">                : mirrorContext.mirror(enclosingClass);</span>
<span class="fc" id="L172">            return new DeclaredTypeImpl(enclosingType, mirrorContext.typeDeclaration(clazz),</span>
<span class="fc" id="L173">                Collections.&lt;ReflectionTypeMirror&gt;emptyList());</span>
        }
    }

    /**
     * Returns a type mirror for the given {@link ParameterizedType} object.
     */
    private static DeclaredTypeImpl mirrorParameterizedType(ParameterizedType parameterizedType,
            MirrorContext mirrorContext) {
<span class="fc" id="L182">        Class&lt;?&gt; rawClass = (Class&lt;?&gt;) parameterizedType.getRawType();</span>
<span class="fc" id="L183">        TypeElementImpl typeDeclaration = mirrorContext.typeDeclaration(rawClass);</span>
<span class="fc" id="L184">        @Nullable Type ownerType = parameterizedType.getOwnerType();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">        ReflectionTypeMirror ownerTypeMirror = ownerType == null</span>
            ? NoTypeImpl.NONE
<span class="fc" id="L187">            : mirrorContext.mirror(ownerType);</span>
<span class="fc" id="L188">        return new DeclaredTypeImpl(ownerTypeMirror, typeDeclaration,</span>
<span class="fc" id="L189">            mirrorContext.mirror(parameterizedType.getActualTypeArguments()));</span>
    }

    /**
     * Returns a type mirror for the given {@link WildcardType} object.
     *
     * &lt;p&gt;The following preconditions are guaranteed by the JLS and the JavaDoc of package {@link java.lang.reflect}:
     * &lt;ul&gt;&lt;li&gt;
     *     {@link WildcardType#getUpperBounds()} specifies: &quot;Note that if no upper bound is explicitly
     *     declared, the upper bound is {@code Object}.&quot;
     * &lt;/li&gt;&lt;li&gt;
     *     While {@link WildcardType#getUpperBounds()} and
     *     {@link WildcardType#getLowerBounds()} return an arrays, JLS §4.5.1 (at least up to
     *     version 8) only supports a single ReferenceType for both bounds.
     * &lt;/li&gt;&lt;/ul&gt;
     */
    private static WildcardTypeImpl mirrorWildcardType(WildcardType wildcardType, MirrorContext mirrorContext) {
<span class="fc" id="L206">        Type[] upperBounds = wildcardType.getUpperBounds();</span>
<span class="fc" id="L207">        Type[] lowerBounds = wildcardType.getLowerBounds();</span>

        // See JavaDoc for an explanation of the following assert statement.
<span class="pc bpc" id="L210" title="3 of 8 branches missed.">        assert upperBounds.length == 1 &amp;&amp; lowerBounds.length &lt;= 1</span>
<span class="pc bpc" id="L211" title="1 of 2 branches missed.">            &amp;&amp; (lowerBounds.length == 0 || Object.class.equals(upperBounds[0]));</span>

        @Nullable ReflectionTypeMirror extendsBounds;
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (Object.class.equals(upperBounds[0])) {</span>
<span class="fc" id="L215">            extendsBounds = null;</span>
        } else {
<span class="fc" id="L217">            extendsBounds = mirrorContext.mirror(upperBounds[0]);</span>
        }

        @Nullable ReflectionTypeMirror superBound;
<span class="fc bfc" id="L221" title="All 2 branches covered.">        if (lowerBounds.length == 0) {</span>
<span class="fc" id="L222">            superBound = null;</span>
        } else {
<span class="fc" id="L224">            superBound = mirrorContext.mirror(lowerBounds[0]);</span>
        }
<span class="fc" id="L226">        return new WildcardTypeImpl(extendsBounds, superBound);</span>
    }

    static void requireCondition(boolean condition, String formatString, Object argument) {
<span class="fc bfc" id="L230" title="All 2 branches covered.">        if (!condition) {</span>
<span class="fc" id="L231">            throw new IllegalStateException(String.format(formatString, argument));</span>
        }
<span class="fc" id="L233">    }</span>

    private static TypeVariableImpl mirrorTypeVariable(TypeVariable&lt;?&gt; typeVariable, MirrorContext mirrorContext) {
<span class="fc" id="L236">        GenericDeclaration genericDeclaration = typeVariable.getGenericDeclaration();</span>
<span class="fc bfc" id="L237" title="All 2 branches covered.">        if (genericDeclaration instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L238">            TypeElementImpl typeDeclaration = mirrorContext.typeDeclaration((Class&lt;?&gt;) genericDeclaration);</span>
<span class="fc" id="L239">            @Nullable TypeParameterElementImpl element = null;</span>
<span class="pc bpc" id="L240" title="1 of 2 branches missed.">            for (TypeParameterElementImpl typeParameter: typeDeclaration.getTypeParameters()) {</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">                if (typeParameter.getSimpleName().contentEquals(typeVariable.getName())) {</span>
<span class="fc" id="L242">                    element = typeParameter;</span>
<span class="fc" id="L243">                    break;</span>
                }
<span class="fc" id="L245">            }</span>
<span class="pc bpc" id="L246" title="1 of 2 branches missed.">            requireCondition(element != null,</span>
                &quot;Could not find the type-parameter element that corresponds to type variable %s.&quot;, typeVariable);
<span class="pc bpc" id="L248" title="2 of 4 branches missed.">            assert element != null : &quot;redundant check for FindBugs&quot;;</span>
<span class="fc" id="L249">            return element.asType();</span>
        } else {
<span class="fc" id="L251">            throw new UnsupportedOperationException(&quot;Method or constructor type parameters not supported.&quot;);</span>
        }
    }

    ReflectionTypeMirror mirrorInternal(Type type, MirrorContext mirrorContext) {
<span class="fc" id="L256">        @Nullable ReflectionTypeMirror typeMirror = null;</span>
<span class="fc bfc" id="L257" title="All 2 branches covered.">        if (type instanceof Class&lt;?&gt;) {</span>
<span class="fc" id="L258">            typeMirror = mirrorClass((Class&lt;?&gt;) type, mirrorContext);</span>
<span class="fc bfc" id="L259" title="All 2 branches covered.">        } else if (type instanceof ParameterizedType) {</span>
<span class="fc" id="L260">            typeMirror = mirrorParameterizedType((ParameterizedType) type, mirrorContext);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">        } else if (type instanceof GenericArrayType) {</span>
<span class="fc" id="L262">            typeMirror = new ArrayTypeImpl(</span>
<span class="fc" id="L263">                mirrorContext.mirror(((GenericArrayType) type).getGenericComponentType())</span>
            );
<span class="fc bfc" id="L265" title="All 2 branches covered.">        } else if (type instanceof WildcardType) {</span>
<span class="fc" id="L266">            typeMirror = mirrorWildcardType((WildcardType) type, mirrorContext);</span>
<span class="pc bpc" id="L267" title="1 of 2 branches missed.">        } else if (type instanceof TypeVariable&lt;?&gt;) {</span>
<span class="fc" id="L268">            typeMirror = mirrorTypeVariable((TypeVariable&lt;?&gt;) type, mirrorContext);</span>
        }
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">        requireCondition(typeMirror != null,</span>
            &quot;Expected Class, ParameterizedType, GenericArrayType, WildcardType, or TypeVariable instance, but got %s.&quot;,
            type);
<span class="pc bpc" id="L273" title="2 of 4 branches missed.">        assert typeMirror != null : &quot;redundant check for FindBugs&quot;;</span>
<span class="fc" id="L274">        return typeMirror;</span>
    }

    /**
     * Returns a type element corresponding to the given {@link Class} object.
     *
     * @param clazz class object
     * @return type element corresponding to the given {@link Class} object
     * @throws IllegalArgumentException if the given class represents a primitive or array type
     * @throws UnsupportedOperationException if a generic declaration is referenced that is not of type {@link Class},
     *     see {@link #typeMirror(Type)} for details
     */
    public TypeElement typeElement(Class&lt;?&gt; clazz) {
<span class="fc bfc" id="L287" title="All 4 branches covered.">        if (clazz.isArray() || clazz.isPrimitive()) {</span>
<span class="fc" id="L288">            throw new IllegalArgumentException(String.format(&quot;Expected class or interface type, but got %s.&quot;, clazz));</span>
        }

<span class="fc" id="L291">        return ((DeclaredTypeImpl) typeMirror(clazz)).asElement();</span>
    }

    /**
     * Returns a type mirror corresponding to the given Java reflection type.
     *
     * &lt;p&gt;Type parameters in method declarations are not currently supported. That is, if the given type references a
     * {@link TypeVariable} instance that has a {@link java.lang.reflect.Constructor} or
     * {@link java.lang.reflect.Method} as generic declaration, an {@link UnsupportedOperationException}
     * will be thrown.
     *
     * @param type type as represented by Java Reflection API
     * @return type mirror corresponding to the given Java reflection type
     * @throws UnsupportedOperationException if a generic declaration is referenced that is not of type {@link Class}
     */
    @Override
    public TypeMirror typeMirror(Type type) {
<span class="fc" id="L308">        Map&lt;Class&lt;?&gt;, TypeElementImpl&gt; typeDeclarations = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L309">        Map&lt;Class&lt;?&gt;, TypeElementImpl&gt; newTypeDeclarations = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L310">        MirrorContext mirrorContext = new MirrorContext(this, typeDeclarations, newTypeDeclarations);</span>

<span class="fc" id="L312">        TypeMirror typeMirror = mirrorInternal(type, mirrorContext);</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">        while (!newTypeDeclarations.isEmpty()) {</span>
<span class="fc" id="L314">            List&lt;TypeElementImpl&gt; typeDeclarationsToFinish = new ArrayList&lt;&gt;(newTypeDeclarations.values());</span>
<span class="fc" id="L315">            typeDeclarations.putAll(newTypeDeclarations);</span>
<span class="fc" id="L316">            newTypeDeclarations.clear();</span>
<span class="fc bfc" id="L317" title="All 2 branches covered.">            for (TypeElementImpl typeDeclaration: typeDeclarationsToFinish) {</span>
<span class="fc" id="L318">                typeDeclaration.finish(mirrorContext);</span>
<span class="fc" id="L319">            }</span>
<span class="fc" id="L320">        }</span>
<span class="fc" id="L321">        return typeMirror;</span>
    }

    private static ImmutableList&lt;ReflectionTypeMirror&gt; toList(TypeMirror[] types) {
<span class="fc" id="L325">        List&lt;ReflectionTypeMirror&gt; list = new ArrayList&lt;&gt;(types.length);</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        for (TypeMirror type: types) {</span>
<span class="fc" id="L327">            list.add((ReflectionTypeMirror) type);</span>
        }
<span class="fc" id="L329">        return ImmutableList.copyOf(list);</span>
    }

    @Override
    public DeclaredType getDeclaredType(@Nullable DeclaredType containing, TypeElement typeElem,
            TypeMirror... typeArgs) {
<span class="fc" id="L335">        requireValidType(containing);</span>
<span class="fc" id="L336">        requireValidElement(typeElem);</span>
<span class="fc" id="L337">        requireValidTypes(typeArgs);</span>

<span class="fc bfc" id="L339" title="All 2 branches covered.">        ReflectionTypeMirror newContainingType = containing == null</span>
            ? NoTypeImpl.NONE
            : (ReflectionTypeMirror) containing;
<span class="fc" id="L342">        return new DeclaredTypeImpl(newContainingType, (TypeElementImpl) typeElem, toList(typeArgs));</span>
    }

    @Override
    public DeclaredType getDeclaredType(TypeElement typeElem, TypeMirror... typeArgs) {
<span class="fc" id="L347">        requireValidElement(typeElem);</span>
<span class="fc" id="L348">        requireValidTypes(typeArgs);</span>

<span class="fc" id="L350">        return new DeclaredTypeImpl(NoTypeImpl.NONE, (TypeElementImpl) typeElem, toList(typeArgs));</span>
    }

    @Override
    public NoType getNoType(TypeKind kind) {
<span class="fc" id="L355">        Objects.requireNonNull(kind);</span>
<span class="fc bfc" id="L356" title="All 2 branches covered.">        if (kind == TypeKind.VOID) {</span>
<span class="fc" id="L357">            return NoTypeImpl.VOID;</span>
<span class="fc bfc" id="L358" title="All 2 branches covered.">        } else if (kind == TypeKind.NONE) {</span>
<span class="fc" id="L359">            return NoTypeImpl.NONE;</span>
        } else {
<span class="fc" id="L361">            throw new IllegalArgumentException(String.format(&quot;Expected one of %s, but got %s.&quot;,</span>
<span class="fc" id="L362">                Arrays.asList(TypeKind.VOID, TypeKind.NONE), kind));</span>
        }
    }

    @Override
    public NullType getNullType() {
<span class="fc" id="L368">        return NullTypeImpl.INSTANCE;</span>
    }

    @Override
    public ArrayType getArrayType(TypeMirror componentType) {
<span class="fc" id="L373">        Objects.requireNonNull(componentType);</span>
<span class="fc" id="L374">        requireValidType(componentType);</span>

<span class="fc" id="L376">        return new ArrayTypeImpl((ReflectionTypeMirror) componentType);</span>
    }

    @Override
    protected javax.lang.model.type.TypeVariable createTypeVariable(TypeParameterElement typeParameter,
            @Nullable javax.lang.model.type.WildcardType capturedTypeArgument) {
<span class="fc" id="L382">        requireValidElement(Objects.requireNonNull(typeParameter));</span>
<span class="fc" id="L383">        requireValidType(capturedTypeArgument);</span>

<span class="fc" id="L385">        return new TypeVariableImpl((TypeParameterElementImpl) typeParameter, (WildcardTypeImpl) capturedTypeArgument);</span>
    }

    @Override
    protected javax.lang.model.type.WildcardType capturedTypeArgument(javax.lang.model.type.TypeVariable typeVariable) {
<span class="fc" id="L390">        requireValidType(Objects.requireNonNull(typeVariable));</span>

<span class="fc" id="L392">        return ((TypeVariableImpl) typeVariable).getCapturedTypeArgument();</span>
    }

    @Override
    public IntersectionType getIntersectionType(TypeMirror... bounds) {
<span class="fc" id="L397">        Objects.requireNonNull(bounds);</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        if (bounds.length == 0) {</span>
<span class="fc" id="L399">            throw new IllegalArgumentException(&quot;Expected at least one bound.&quot;);</span>
        }
<span class="fc" id="L401">        requireValidTypes(bounds);</span>

<span class="fc" id="L403">        List&lt;ReflectionTypeMirror&gt; newBounds = new ArrayList&lt;&gt;(bounds.length);</span>
<span class="fc bfc" id="L404" title="All 2 branches covered.">        for (TypeMirror bound: bounds) {</span>
<span class="fc" id="L405">            newBounds.add((ReflectionTypeMirror) bound);</span>
        }

<span class="fc" id="L408">        return new IntersectionTypeImpl(newBounds);</span>
    }

    @Override
    protected void setTypeVariableBounds(javax.lang.model.type.TypeVariable typeVariable, TypeMirror upperBound,
            TypeMirror lowerBound) {
<span class="fc" id="L414">        requireValidType(Objects.requireNonNull(typeVariable));</span>
<span class="fc" id="L415">        requireValidType(Objects.requireNonNull(upperBound));</span>
<span class="fc" id="L416">        requireValidType(Objects.requireNonNull(lowerBound));</span>

<span class="fc" id="L418">        ((TypeVariableImpl) typeVariable).setUpperAndLowerBounds(</span>
            (ReflectionTypeMirror) upperBound,
            (ReflectionTypeMirror) lowerBound
        );
<span class="fc" id="L422">    }</span>

    @Override
    public PrimitiveType getPrimitiveType(TypeKind kind) {
<span class="fc" id="L426">        @Nullable PrimitiveTypeImpl primitiveType = primitiveTypes.get(kind.ordinal());</span>
<span class="fc bfc" id="L427" title="All 2 branches covered.">        if (primitiveType == null) {</span>
<span class="fc" id="L428">            throw new IllegalArgumentException(String.format(&quot;Expected primitive kind, but got %s.&quot;, kind));</span>
        }
<span class="fc" id="L430">        return primitiveType;</span>
    }

    @Override
    public javax.lang.model.type.WildcardType getWildcardType(@Nullable TypeMirror extendsBound,
            @Nullable TypeMirror superBound) {
<span class="fc" id="L436">        requireValidType(extendsBound);</span>
<span class="fc" id="L437">        requireValidType(superBound);</span>

<span class="fc" id="L439">        return new WildcardTypeImpl((ReflectionTypeMirror) extendsBound, (ReflectionTypeMirror) superBound);</span>
    }

    private static UnsupportedOperationException unsupportedException() {
<span class="fc" id="L443">        return new UnsupportedOperationException(</span>
            &quot;isAssignable(), isSubsignature(), asMemberOf(), and directSupertypes() not currently supported.&quot;
        );
    }

    @Override
    public boolean isAssignable(TypeMirror t1, TypeMirror t2) {
<span class="fc" id="L450">        throw unsupportedException();</span>
    }

    @Override
    public boolean isSubsignature(ExecutableType m1, ExecutableType m2) {
<span class="nc" id="L455">        throw unsupportedException();</span>
    }

    @Override
    public TypeMirror asMemberOf(DeclaredType containing, Element element) {
<span class="fc" id="L460">        throw unsupportedException();</span>
    }

    /**
     * @throws UnsupportedOperationException whenever this method is called
     */
    @Override
    public List&lt;? extends TypeMirror&gt; directSupertypes(TypeMirror t) {
<span class="fc" id="L468">        throw unsupportedException();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.4.201502262128</span></div></body></html>